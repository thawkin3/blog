# The 8 Biggest Software Engineering Challenges Your Team Faces

Software engineering is difficult. Contrary to what you might think, the challenges often arise not from technical problems, but from organizational and people problems. After all, companies are composed of people, and people aren’t as straightforward as machines.

Let’s look at eight challenges in software engineering and explore their potential solutions.

## #1: Unclear Requirements

In a typical software development lifecycle, product owners set the vision for what to build, UX designers create mocks for the functionality, software engineers turn those mocks into code, QA engineers test for bugs, and the feature is released. All of this happens more or less iteratively, depending on how much your company embraces agile principles.

Sometimes agile methodology is misunderstood to mean “no planning” and “no requirements” or “vague plans” and “vague requirements.” Developers may be asked to build something even when it’s not very clear what exactly they should be building. This often leads to frustration. Additionally, even the best plans tend to change midway through the project.

**Possible solutions**: Keep projects small. It’s much easier to pivot on strategy when average project lengths are measured in terms of weeks rather than months or years. If it often feels like projects are started before they’re really ready, then create a “definition of ready” that the organization adheres to. A project cannot be started until it meets those criteria.

## #2: Too Many Priorities

If everything is important, nothing is. It’s inefficient for teams to work on 10 projects at once. You’ll likely make a fraction of progress on each thing, accomplishing nothing.

While multitasking sounds nice in theory, fragmented attention leads to lower-quality work and longer timelines.

**Possible solutions**: Work on one thing at a time. As a team, prioritize what is most important, and tackle that one thing. Set expectations with stakeholders regarding what the team is working on, and [don’t get distracted](https://humanskills.blog/time-management-matrix/) by every “urgent” request that comes your way.

## #3: Too Many Meetings

Businesses love meetings. We meet for everything. This works well for those required to be in meetings, but this poses a problem for those who need to build. If you spend all your time in planning meetings, when will the development get done?

You may be spending more time estimating tasks and sizing projects than actually completing them. You may have meetings evenly spaced throughout your day, leaving you with small chunks of time in between meetings, during which you can’t accomplish anything meaningful.

**Possible solutions**: Set time in your day to [work in blocks of at least 90 minutes](https://www.calnewport.com/books/deep-work/). Try to group meetings together towards the beginning or end of your day. Cancel or decline meetings that serve no purpose. Avoid nitpicking during planning. “Should this story be sized as a 2 or a 3?” Either is great; let’s move on.

## #4: Reorgs

Engineering organizations change a lot. There are new hires, employee attrition, team structure changes, and the occasional layoffs. Reorgs are particularly painful.

Each reorg brings with it a new team, a new manager, and/or new projects. It takes time for developers to get up to speed and to be productive again.

**Possible solutions**: For engineering leaders, understand the productivity loss that reorgs bring, and only drastically change your org structure when absolutely necessary. Do everything you can to reduce employee turnover.

## #5: Inefficient Code Reviews

Developers love to hate code reviews. Merge requests may sit unreviewed for long periods of time. Code reviews may be full of nitpicking and passive-aggressive comments. Developers aren’t often known for their communication skills, and that’s a shame.

**Possible solutions**: Establish code review service level agreements (SLAs) for how soon code will be reviewed. Establish [code review best practices](https://mtlynch.io/code-review-love/). Document and review these practices as a team. Use [merge request templates](https://betterprogramming.pub/a-checklist-manifesto-3f686ed135f8?sk=e3e0599f980d66c0b222f068b74f51f7). Set clear code standards. Automate what you can.

## #6: Context Switching

Context switching is the nemesis of deep work. It takes time for your mind to get back into its groove when switching between email, Slack, meetings, your browser, and your IDE. Interruptions cause a productivity loss much greater than the actual amount of time for which the interruption lasted.

**Possible solutions**: Turn off your notifications. Only check messages at specific times during the day. Schedule periods of deep work into your day. Consider using an AI code assistant like [Tabnine](https://www.tabnine.com/) to help keep you in your IDE longer. Tabnine’s code completion can provide helpful suggestions as you code, meaning that you won’t have to search Google every time you forget something in the programming language’s syntax or can’t remember an API’s methods and best practices.

## #7: Maintaining Legacy Software

Not all projects are exciting greenfield apps. In fact, most code is legacy code. This code is often poorly documented and severely lacking in automated tests. You may be nervous any time you merge changes because you’re not sure what will break this time.

**Possible solutions**: [Write tests](https://dev.to/thawkin3/tests-are-for-the-future-3a4d) with each new merge request. Document everything. Refactor code as needed. Move mental models out of your head and into the code. Improving legacy software is no small feat, but it can help you improve, little by little.

## #8: Poor Timeline Management

Humans are bad at estimating. [Research shows](https://freakonomics.com/podcast/heres-why-all-your-projects-are-always-late-and-what-to-do-about-it/) that software engineering projects, much like road construction projects, are usually anywhere from 50% to 100% over the original time estimate by the time they’re completed. When multiple teams or other external dependencies are involved, the problem worsens.

**Possible solutions**: Once you have an estimate, double it. Identify project risks early on, and ensure those risks are accounted for. Create timelines for best-case, average-case, and worst-case scenarios. Use project management software to identify the critical path for each project.

## Conclusion

Those are eight of the biggest challenges your team faces regarding software engineering. By taking advantage of and implementing some of the possible solutions listed above, you can improve the productivity and efficiency of your software engineering team and deliver more value faster to your organization and customers.
